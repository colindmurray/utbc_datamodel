\documentclass{report}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage[margin=1in]{geometry}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{listings}

\linespread{1.5}

\lstdefinelanguage{SQL}{
	keywords = {,SELECT ,FROM,JOIN,ON,WHERE, GROUP BY, AS, AND, OR, BETWEEN, UPDATE, SET, INTO,INSERT,insert,}
	sensitive=false,
	keywordstyle = \color{blue},
	ndkeywords={}
	ndkeywordstyle = \color{red}\bfseries,
	stringstyle = \ttfamily
}
\lstset{
	language = SQL,
	extendedchars = true,
	basicstyle = \color{red}\ttfamily,
	numbers = left,
	frame = leftline
	}
\begin{document}

\title{\bfseries UT Business Contracts Application Documentation}

\author{
	Coling Murray (Team Leader)
	\and
	Calvin Aisenbrey
	\and
	Alex Landaverde
	\and
	Chris Metcalf
	\and
	Ashley Ng
}

\maketitle

\begin{abstract}
Put abstract here
\end{abstract}

\tableofcontents

\newpage

\begin{image}
\centering
\includegraphics[height = 4.5in, angle = 90]{UTBC_model}
\end{image}



\chapter{Data model}

\section{Contract Table}

\section{UTBC\_approvals and UTBC\_Agree\_App Tables}
Chris & Alex

\section{UTBC\_triggers and UTBC\_Agree\_Trig Tables}
Chris & Alex

\chapter{Application}

\section{Home Page}
The home page consists of three different tables; contracts, ticklers, and BOR dates. The tables only displays contracts that are renewable and are expiring in the next 60 days. The table also only displays contracts that pertain to the user logged in using the where clause

\begin{lstlisting}[caption=Contracts table where clause for user]
WHERE reviewed_by APEX_UTIL.GET_SESSION_STATE('APP_USER')
\end{lstlisting}

The next table is ticklers (or reminders), which only displays ticklers pertaining to the user that is logged in as well as public ticklers for everyone to see. We used the following where clause to do this

\begin{lstlisting}[caption=Tickler table where clause]
WHERE t.created_by = APEX_UTIL.GET_SESSION_STATE('APP_USER')
OR PUBLIC_T = 'Y'
\end{lstlisting}

In this ticklers table, two tables are joined; the UTBC\_ticklers and UTBC\_contact tables. That way the user can easily email the corresponding person about the tickler. 
The next table is BOR dates (or board of regents dates). This table has no connect do our data model and is a stand alone table. The table has two attributes, due date and meeting date. The due date is the day the office will have to get certain paperwork submitted to be on the associated meeting date.

\section{Agreements Home Page}

\subsection{Agreements Tree}
Colin

\subsection{Agreements Search Bar}
Colin 

\subsection{Agreements Sorting}
Calvin

\subsection{Agreements Form}
Ashley

\section{Agreements Details Page}

\subsection{Purpose region}
Calvin

\subsection{Related Region}
colin

\subsection{Notes Region}
calvin

\subsection{Add Sub-Agreement, Add Version}
The add sub-agreements button takes the agreement\_id of the viewed agreement, and passes it to the item P23\_agreement\_parent on the form. The top level contract's agreement parent should be null because it has not parent, and setting the agreement parent relates the sub-agreement to it's parent contract.

There are two add version buttons, the first one allows you to create a new version based on the max version for the agreement. We pass five different values; the first one is we pass what the next version(\&P4\_Next\_version) would be into P23\_version. The \&P4\_next\_version just uses a query to get the max version of the contract

\begin{lstlisting}
select * from utbc_agreements
\end{lstlisting}

The next item is the contract number, which connects the version to it's proper contract. The next assignment is the version parent, and this is just to keep things organized. The next item is the version\_id value that get's it's value from \&P4\_max\_agreement which uses a query to get what the agreement id of the max version. The form then uses this value to populate itself. Normally a form would have an "apply changes button" if the primary key is not null. To work around this the \&P4\_blank value is null and that is passed into the P23\_agreement\_id, so that the version id can be the one to populate the form; this way the form is going to be a create. 

Other version button

\subsection{Approvals Region}
Chris

\section{Other Forms}

\subsection{Vendor Form}

\subsection{Department Form}

\subsection{Tickler Form}

\subsection{Document Form}
The documents form uses a file drop plug-in that was downloaded at apex-plugin.com, and was created by Damien Antipa. The file drop plugin automatically does an insert into the table (as seen from the following code) once you drop the file into the file drop window. This causes an issue for the user because they have yet to finished completing the document form, or if the user uploaded the incorrect document, or decides to cancel the form. To get around this, the document\_id was returned in the PL/SQL statement after the insert

\begin{lstlisting}[caption = PL/SQL on filedrop item]
DECLARE
  c_collection_name constant varchar2(200):='CLOB_CONTENT';
  l_blobBLOB;
  l_mime				     varchar2(50);
BEGIN
  SELECT apex_web_service.clobbase642blob(
  	substr(clob001, ',')+1, length(clob001)))
  INTO l_blob
  from apex_collections
  where collection_name = c_collection_name
  
  insert into UTBC_document(FILE_DATA, filename, 
  	file_mimetype, AGREEMENT_ID) 
  values(l_blob, wwv_flow.g_x01, wwv_flow.g_x02, :P28_agreement_id)
  returning document_id into :P28_document_id;
END;
\end{lstlisting}

If the user now decided that they want to cancel the form, a dynamic action fires when the user clicks the cancel button, and executes PL/SQL code

\begin{lstlisting}[caption=close dialog PL/SQL]
BEGIN
delete from UTBC_document where document_id = :P28_document_id;
END;
\end{lstlisting}

Because the file browse and file drop both have different ways of inserting the blob into the table, two different create buttons were made. One handling the file browse and another handling the file drop, but only one is ever displayed at a time because of a IS NOT NULL or IS NULL condition on the item P28\_FILENAME\_SHOW. The item is initially null, and then will be filled with the text ``*filename* uploaded" once the file drop has done the insert. 
One of the create buttons is the original create button that handles the file browse option. The other create button for the file drop option has PL/SQL code that fires when the corresponding create button is clicked. 

\begin{lstlisting}[caption=update statement for filedrop]
BEGIN
	update UTBC_document
	SEt
	file_comments = :P28_file_comments, 
	tags = :P28_tags,
	where document_id = :P28_document_id;
END;
\end{lstlisting}

At this point there is no indication when a file is successfully uploaded/inserted with the file drop. The was handled using a dynamic action event that came with the plug-in, upload ended.  To do this, a dynamic action was created on the upload ended event on the file drop item. A false action was created to fire on page load, to hide the P28\_FILENAME\_SHOW item. Next, several true actions were set up, the first being to hide the file drop window. The next was to set this P28\_FILENAME\_SHOW with the filename. A cancel upload button will also be shown after upload. This button is incase the user has accidentally selected the incorrect file. When the button is clicked, a dynamic action fires that will delete the corresponding file, show the file drop region again, and then set the P28\_FILENAME\_SHOW item back to null.


\section{Vendor, Department, and Contacts Page}
These three pages are just interactive reports on their corresponding tables. The pencil icon allows you to edit the selected row with a modal. While, the magnifying glass takes you to a simple details page for the item. The state fields for the vendors and contacts are dynamic LOVs from the UTBC\_state table, as well as the country field for the UTBC\_country table. Our contacts table stores vendor and department contact so there is a type fields on the contact form that distinguishes the two.



\end{document}